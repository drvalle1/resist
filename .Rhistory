b.gamma=2
z=sample(1:ngroups,size=n.ysoma,replace=T)
theta=rep(1/ngroups,ngroups)
#stuff for gibbs sampler
w=0.1
MaxIter=100
ngibbs=10000
nburn=ngibbs/2
jump1=list(b.gamma=1)
accept1=list(b.gamma=0)
store.betas=matrix(NA,ngibbs,nparam*ngroups)
store.z=matrix(NA,ngibbs,n.ysoma)
store.b=matrix(NA,ngibbs,1)
store.llk=matrix(NA,ngibbs,1)
nadapt=50
betas=Sample_betas(ngroups=ngroups,nparam=nparam,xmat=xmat,z=z,
ysoma=ysoma,betas=betas,b.gamma=b.gamma,var.betas=var.betas,
w=w,MaxIter=MaxIter,seg.id=seg.id)
betas
rm(list=ls())
set.seed(1)
setwd('U:\\GIT_models\\resist')
source('gibbs_resist_func.R')
source('slice_betas.R')
dat=read.csv('fake data.csv',as.is=T)
n=nrow(dat)
ind=grep('cov',colnames(dat))
xmat=data.matrix(cbind(1,dat[,ind]))
nparam=ncol(xmat)
seg.id=dat$seg.id
#get y soma
tmp=unique(dat[,c('seg.id','ysoma')])
cond=!is.na(tmp$ysoma)
ysoma=tmp[cond,'ysoma']
n.ysoma=length(ysoma)
#priors
var.betas=c(100,rep(1,nparam-1))
gamma1=0.1
#initial parameters
ngroups=4
betas=matrix(0,nparam,ngroups)
b.gamma=2
z=sample(1:ngroups,size=n.ysoma,replace=T)
theta=rep(1/ngroups,ngroups)
#stuff for gibbs sampler
w=0.1
MaxIter=100
ngibbs=10000
nburn=ngibbs/2
jump1=list(b.gamma=1)
accept1=list(b.gamma=0)
store.betas=matrix(NA,ngibbs,nparam*ngroups)
store.z=matrix(NA,ngibbs,n.ysoma)
store.b=matrix(NA,ngibbs,1)
store.llk=matrix(NA,ngibbs,1)
nadapt=50
for (i in 1:ngibbs){
print(i)
#sample betas
betas=Sample_betas(ngroups=ngroups,nparam=nparam,xmat=xmat,z=z,
ysoma=ysoma,betas=betas,b.gamma=b.gamma,var.betas=var.betas,
w=w,MaxIter=MaxIter,seg.id=seg.id)
# tmp=sample.betas(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$betas,
#                  b.gamma=b.gamma,nparam=nparam,var.betas=var.betas,
#                  seg.id=seg.id,z=z,ngroups=ngroups,n=n)
# betas=tmp$betas
# accept1$betas=accept1$betas+tmp$accept
# betas=betas.true
#sample b.gamma
tmp=sample.b.gamma(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$b.gamma,
b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
b.gamma=tmp$b.gamma
accept1$b.gamma=accept1$b.gamma+tmp$accept
#sample z
z=sample.z(xmat=xmat,betas=betas,n.ysoma=n.ysoma,ngroups=ngroups,seg.id=seg.id,
b.gamma=b.gamma,ysoma=ysoma,ltheta=log(theta))
# z=aux.true$z
#estimate theta
theta=sample.theta(z=z,gamma1=gamma1,ngroups=ngroups)
#get llk
llk=get.llk(betas=betas,xmat=xmat,ysoma=ysoma,b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
#store results
store.betas[i,]=betas
store.b[i]=b.gamma
store.llk[i]=llk
store.z[i,]=z
#adapt MH
if (i%%nadapt==0 & i<nburn){
for (j in 1:length(jump1)){
accept.rate=accept1[[j]]/nadapt
jump.tmp=jump1[[j]]
print(accept.rate)
cond=accept.rate<0.1; jump.tmp[cond]=jump.tmp[cond]/2
cond=accept.rate>0.5; jump.tmp[cond]=jump.tmp[cond]*2
jump1[[j]]=jump.tmp
accept1[[j]]=rep(0,length(jump.tmp))
}
}
}
betas
rm(list=ls())
set.seed(1)
#calculate covariates
setwd('U:\\GIT_models\\resist')
xmat=read.csv('spatially correlated xmat.csv',as.is=T)
xmat=data.matrix(xmat)
nomes.cov=colnames(xmat)
n=nrow(xmat)
#get groups
ngroup=4
init1=sort(c(1,sample(1:n,size=n/10)))
end1=c(init1[-1]-1,n)
aux.true=aux=data.frame(init1=init1,end1=end1,z=sample(1:ngroup,size=length(init1),replace=T))
#get media
nparam=6
betas.true=betas=matrix(c(-1,0 ,1,0,-1,0,
1,0 ,1,0, 1,0,
-1,-1,0,0,0,0,
0, 0,1,1,0,0),nparam,ngroup)
media=exp(cbind(1,xmat)%*%betas)
b.true=b=0.5
atmp=b*media
#generate data
a.gamma=rep(NA,n)
for (i in 1:n){
cond=i >= aux.true$init1 & i <= aux.true$end1
z=aux.true$z[cond]
a.gamma[i]=atmp[i,z]
}
y=rgamma(n,a.gamma,b)
fim=as.data.frame(cbind(y,xmat))
#aggregate these data
fim$ysoma=NA
fim$seg.id=NA
for (i in 1:nrow(aux)){
seq1=aux$init1[i]:aux$end1[i]
fim$seg.id[seq1]=i
if (n==1) ysoma=fim[seq1,'y']
if (n> 1) ysoma=sum(fim[seq1,'y'])
fim$ysoma[aux$end1[i]]=ysoma
}
ind=which(colnames(fim)=='y')
setwd('U:\\GIT_models\\resist')
write.csv(fim[,-ind],'fake data.csv',row.names=F)
rm(list=ls())
set.seed(1)
#calculate covariates
setwd('U:\\GIT_models\\resist')
xmat=read.csv('spatially correlated xmat.csv',as.is=T)
xmat=data.matrix(xmat)
nomes.cov=colnames(xmat)
n=nrow(xmat)
#get groups
ngroup=4
init1=sort(c(1,sample(1:n,size=n/10)))
end1=c(init1[-1]-1,n)
aux.true=aux=data.frame(init1=init1,end1=end1,z=sample(1:ngroup,size=length(init1),replace=T))
#get media
nparam=6
betas.true=betas=matrix(c(-1,0 ,1,0,-1,0,
1,0 ,1,0, 1,0,
-1,-1,0,0,0,0,
0, 0,1,1,0,0),nparam,ngroup)
media=exp(cbind(1,xmat)%*%betas)
b.true=b=0.5
atmp=b*media
#generate data
a.gamma=rep(NA,n)
for (i in 1:n){
cond=i >= aux.true$init1 & i <= aux.true$end1
z=aux.true$z[cond]
a.gamma[i]=atmp[i,z]
}
y=rgamma(n,a.gamma,b)
fim=as.data.frame(cbind(y,xmat))
#aggregate these data
fim$ysoma=NA
fim$seg.id=NA
for (i in 1:nrow(aux)){
seq1=aux$init1[i]:aux$end1[i]
fim$seg.id[seq1]=i
if (n==1) ysoma=fim[seq1,'y']
if (n> 1) ysoma=sum(fim[seq1,'y'])
fim$ysoma[aux$end1[i]]=ysoma
}
ind=which(colnames(fim)=='y')
setwd('U:\\GIT_models\\resist')
write.csv(fim[,-ind],'fake data.csv',row.names=F)
set.seed(1)
setwd('U:\\GIT_models\\resist')
source('gibbs_resist_func.R')
source('slice_betas.R')
dat=read.csv('fake data.csv',as.is=T)
n=nrow(dat)
ind=grep('cov',colnames(dat))
xmat=data.matrix(cbind(1,dat[,ind]))
nparam=ncol(xmat)
seg.id=dat$seg.id
#get y soma
tmp=unique(dat[,c('seg.id','ysoma')])
cond=!is.na(tmp$ysoma)
ysoma=tmp[cond,'ysoma']
n.ysoma=length(ysoma)
#priors
var.betas=c(100,rep(1,nparam-1))
gamma1=0.1
#initial parameters
ngroups=4
betas=matrix(0,nparam,ngroups)
b.gamma=2
z=sample(1:ngroups,size=n.ysoma,replace=T)
theta=rep(1/ngroups,ngroups)
#stuff for gibbs sampler
w=0.1
MaxIter=100
ngibbs=10000
nburn=ngibbs/2
jump1=list(b.gamma=1)
accept1=list(b.gamma=0)
store.betas=matrix(NA,ngibbs,nparam*ngroups)
store.z=matrix(NA,ngibbs,n.ysoma)
store.b=matrix(NA,ngibbs,1)
store.llk=matrix(NA,ngibbs,1)
nadapt=50
for (i in 1:ngibbs){
print(i)
#sample betas
betas=Sample_betas(ngroups=ngroups,nparam=nparam,xmat=xmat,z=z,
ysoma=ysoma,betas=betas,b.gamma=b.gamma,var.betas=var.betas,
w=w,MaxIter=MaxIter,seg.id=seg.id)
# tmp=sample.betas(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$betas,
#                  b.gamma=b.gamma,nparam=nparam,var.betas=var.betas,
#                  seg.id=seg.id,z=z,ngroups=ngroups,n=n)
# betas=tmp$betas
# accept1$betas=accept1$betas+tmp$accept
# betas=betas.true
#sample b.gamma
# tmp=sample.b.gamma(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$b.gamma,
#                    b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
# b.gamma=tmp$b.gamma
# accept1$b.gamma=accept1$b.gamma+tmp$accept
b.gamma=b.true
#sample z
# z=sample.z(xmat=xmat,betas=betas,n.ysoma=n.ysoma,ngroups=ngroups,seg.id=seg.id,
#            b.gamma=b.gamma,ysoma=ysoma,ltheta=log(theta))
z=aux.true$z
#estimate theta
theta=sample.theta(z=z,gamma1=gamma1,ngroups=ngroups)
#get llk
llk=get.llk(betas=betas,xmat=xmat,ysoma=ysoma,b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
#store results
store.betas[i,]=betas
store.b[i]=b.gamma
store.llk[i]=llk
store.z[i,]=z
#adapt MH
if (i%%nadapt==0 & i<nburn){
for (j in 1:length(jump1)){
accept.rate=accept1[[j]]/nadapt
jump.tmp=jump1[[j]]
print(accept.rate)
cond=accept.rate<0.1; jump.tmp[cond]=jump.tmp[cond]/2
cond=accept.rate>0.5; jump.tmp[cond]=jump.tmp[cond]*2
jump1[[j]]=jump.tmp
accept1[[j]]=rep(0,length(jump.tmp))
}
}
}
set.seed(1)
setwd('U:\\GIT_models\\resist')
source('gibbs_resist_func.R')
source('slice_betas.R')
dat=read.csv('fake data.csv',as.is=T)
n=nrow(dat)
ind=grep('cov',colnames(dat))
xmat=data.matrix(cbind(1,dat[,ind]))
nparam=ncol(xmat)
seg.id=dat$seg.id
#get y soma
tmp=unique(dat[,c('seg.id','ysoma')])
cond=!is.na(tmp$ysoma)
ysoma=tmp[cond,'ysoma']
n.ysoma=length(ysoma)
#priors
var.betas=c(100,rep(1,nparam-1))
gamma1=0.1
#initial parameters
ngroups=4
betas=matrix(0,nparam,ngroups)
b.gamma=2
z=sample(1:ngroups,size=n.ysoma,replace=T)
theta=rep(1/ngroups,ngroups)
#stuff for gibbs sampler
w=0.1
MaxIter=100
ngibbs=10000
nburn=ngibbs/2
jump1=list(b.gamma=1)
accept1=list(b.gamma=0)
store.betas=matrix(NA,ngibbs,nparam*ngroups)
store.z=matrix(NA,ngibbs,n.ysoma)
store.b=matrix(NA,ngibbs,1)
store.llk=matrix(NA,ngibbs,1)
nadapt=50
for (i in 1:ngibbs){
print(i)
#sample betas
betas=Sample_betas(ngroups=ngroups,nparam=nparam,xmat=xmat,z=z,
ysoma=ysoma,betas=betas,b.gamma=b.gamma,var.betas=var.betas,
w=w,MaxIter=MaxIter,seg.id=seg.id)
# tmp=sample.betas(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$betas,
#                  b.gamma=b.gamma,nparam=nparam,var.betas=var.betas,
#                  seg.id=seg.id,z=z,ngroups=ngroups,n=n)
# betas=tmp$betas
# accept1$betas=accept1$betas+tmp$accept
# betas=betas.true
#sample b.gamma
# tmp=sample.b.gamma(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$b.gamma,
#                    b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
# b.gamma=tmp$b.gamma
# accept1$b.gamma=accept1$b.gamma+tmp$accept
b.gamma=b.true
#sample z
# z=sample.z(xmat=xmat,betas=betas,n.ysoma=n.ysoma,ngroups=ngroups,seg.id=seg.id,
#            b.gamma=b.gamma,ysoma=ysoma,ltheta=log(theta))
z=aux.true$z
#estimate theta
theta=sample.theta(z=z,gamma1=gamma1,ngroups=ngroups)
#get llk
llk=get.llk(betas=betas,xmat=xmat,ysoma=ysoma,b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
#store results
store.betas[i,]=betas
store.b[i]=b.gamma
store.llk[i]=llk
store.z[i,]=z
#adapt MH
if (i%%nadapt==0 & i<nburn){
for (j in 1:length(jump1)){
accept.rate=accept1[[j]]/nadapt
jump.tmp=jump1[[j]]
print(accept.rate)
cond=accept.rate<0.1; jump.tmp[cond]=jump.tmp[cond]/2
cond=accept.rate>0.5; jump.tmp[cond]=jump.tmp[cond]*2
jump1[[j]]=jump.tmp
accept1[[j]]=rep(0,length(jump.tmp))
}
}
}
betas
round(betas,3)
rm(list=ls())
set.seed(1)
#calculate covariates
setwd('U:\\GIT_models\\resist')
xmat=read.csv('spatially correlated xmat.csv',as.is=T)
xmat=data.matrix(xmat)
dim(xmat)
colnames(xmat)
rm(list=ls())
set.seed(1)
#calculate covariates
setwd('U:\\GIT_models\\resist')
n=10000
nparam=5
xmat=matrix(runif(n*nparam,min=-1,max=1),n,nparam)
nomes.cov=paste0('covs',1:nparam)
colnames(xmat)=nomes.cov
n=nrow(xmat)
#get groups
ngroup=4
init1=sort(c(1,sample(1:n,size=n/10)))
end1=c(init1[-1]-1,n)
aux.true=aux=data.frame(init1=init1,end1=end1,z=sample(1:ngroup,size=length(init1),replace=T))
#get media
nparam=6
betas.true=betas=matrix(c(-1,0 ,1,0,-1,0,
1,0 ,1,0, 1,0,
-1,-1,0,0,0,0,
0, 0,1,1,0,0),nparam,ngroup)
media=exp(cbind(1,xmat)%*%betas)
b.true=b=0.5
atmp=b*media
#generate data
a.gamma=rep(NA,n)
for (i in 1:n){
cond=i >= aux.true$init1 & i <= aux.true$end1
z=aux.true$z[cond]
a.gamma[i]=atmp[i,z]
}
y=rgamma(n,a.gamma,b)
fim=as.data.frame(cbind(y,xmat))
#aggregate these data
fim$ysoma=NA
fim$seg.id=NA
for (i in 1:nrow(aux)){
seq1=aux$init1[i]:aux$end1[i]
fim$seg.id[seq1]=i
if (n==1) ysoma=fim[seq1,'y']
if (n> 1) ysoma=sum(fim[seq1,'y'])
fim$ysoma[aux$end1[i]]=ysoma
}
ind=which(colnames(fim)=='y')
setwd('U:\\GIT_models\\resist')
write.csv(fim[,-ind],'fake data.csv',row.names=F)
set.seed(1)
setwd('U:\\GIT_models\\resist')
source('gibbs_resist_func.R')
source('slice_betas.R')
dat=read.csv('fake data.csv',as.is=T)
n=nrow(dat)
ind=grep('cov',colnames(dat))
xmat=data.matrix(cbind(1,dat[,ind]))
nparam=ncol(xmat)
seg.id=dat$seg.id
#get y soma
tmp=unique(dat[,c('seg.id','ysoma')])
cond=!is.na(tmp$ysoma)
ysoma=tmp[cond,'ysoma']
n.ysoma=length(ysoma)
#priors
var.betas=c(100,rep(1,nparam-1))
gamma1=0.1
#initial parameters
ngroups=4
betas=matrix(0,nparam,ngroups)
b.gamma=2
z=sample(1:ngroups,size=n.ysoma,replace=T)
theta=rep(1/ngroups,ngroups)
#stuff for gibbs sampler
w=0.1
MaxIter=100
ngibbs=10000
nburn=ngibbs/2
jump1=list(b.gamma=1)
accept1=list(b.gamma=0)
store.betas=matrix(NA,ngibbs,nparam*ngroups)
store.z=matrix(NA,ngibbs,n.ysoma)
store.b=matrix(NA,ngibbs,1)
store.llk=matrix(NA,ngibbs,1)
nadapt=50
for (i in 1:ngibbs){
print(i)
#sample betas
betas=Sample_betas(ngroups=ngroups,nparam=nparam,xmat=xmat,z=z,
ysoma=ysoma,betas=betas,b.gamma=b.gamma,var.betas=var.betas,
w=w,MaxIter=MaxIter,seg.id=seg.id)
# tmp=sample.betas(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$betas,
#                  b.gamma=b.gamma,nparam=nparam,var.betas=var.betas,
#                  seg.id=seg.id,z=z,ngroups=ngroups,n=n)
# betas=tmp$betas
# accept1$betas=accept1$betas+tmp$accept
# betas=betas.true
#sample b.gamma
# tmp=sample.b.gamma(betas=betas,xmat=xmat,ysoma=ysoma,jump=jump1$b.gamma,
#                    b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
# b.gamma=tmp$b.gamma
# accept1$b.gamma=accept1$b.gamma+tmp$accept
b.gamma=b.true
#sample z
# z=sample.z(xmat=xmat,betas=betas,n.ysoma=n.ysoma,ngroups=ngroups,seg.id=seg.id,
#            b.gamma=b.gamma,ysoma=ysoma,ltheta=log(theta))
z=aux.true$z
#estimate theta
theta=sample.theta(z=z,gamma1=gamma1,ngroups=ngroups)
#get llk
llk=get.llk(betas=betas,xmat=xmat,ysoma=ysoma,b.gamma=b.gamma,seg.id=seg.id,z=z,n=n)
#store results
store.betas[i,]=betas
store.b[i]=b.gamma
store.llk[i]=llk
store.z[i,]=z
#adapt MH
if (i%%nadapt==0 & i<nburn){
for (j in 1:length(jump1)){
accept.rate=accept1[[j]]/nadapt
jump.tmp=jump1[[j]]
print(accept.rate)
cond=accept.rate<0.1; jump.tmp[cond]=jump.tmp[cond]/2
cond=accept.rate>0.5; jump.tmp[cond]=jump.tmp[cond]*2
jump1[[j]]=jump.tmp
accept1[[j]]=rep(0,length(jump.tmp))
}
}
}
betas
plot(store.llk,type='l')
nburn=8000
abline(v=nburn,col='red')
plot(store.llk[nburn:ngibbs],type='l')
round(apply(store.betas[nburn:ngibbs,],2,mean),2)
plot(store.b,type='l')
plot(store.b[nburn:ngibbs],type='l')
round(apply(store.betas[nburn:ngibbs,],2,mean),2)
plot(store.b,type='l')
betas.estim=matrix(store.betas[ngibbs,],nparam,ngroups)
plot(betas.estim[,ordem],betas.true)
nparam=6
betas.true=betas=matrix(c(-1,0 ,1,0,-1,0,
1,0 ,1,0, 1,0,
-1,-1,0,0,0,0,
0, 0,1,1,0,0),nparam,ngroup)
betas.estim=matrix(store.betas[ngibbs,],nparam,ngroups)
plot(betas.estim[,ordem],betas.true)
ordem=1:ngroups
betas.estim=matrix(store.betas[ngibbs,],nparam,ngroups)
plot(betas.estim[,ordem],betas.true)
betas.estim=matrix(store.betas[ngibbs,],nparam,ngroups)
rango=range(c(betas.estim,betas.true))
plot(betas.estim[,ordem],betas.true,xlim=rango,ylim=rango)
lines(rango,rango,col='red')
exp(0.6)
log(4)
